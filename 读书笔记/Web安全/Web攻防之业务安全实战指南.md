## 一、理论

### 1、测试流程

```python
# 1、测试准备
白盒：结合相关开发文档熟悉相关系统业务。
黑盒：通过实际操作还原业务流程的方式理解业务。
```

```python
# 2、业务调研
白盒：对业务系统相关负责人进行访谈调研，了解业务系统的整体情况。包括部署情况、功能模块、业务流程、数据流、业务逻辑以及现有的安全措施等。
黑盒：跳过此步骤。
```

```python
# 3、业务场景建模
针对不同行业、不同平台的业务系统，识别处其中的高风险业务场景进行建模。
```

```python
# 4、业务流程梳理
思考维度：
	前台、后台、业务、支撑系统。
思考方向：
	各个业务模块的业务逻辑、业务数据流和功能字段等。
原则：
	a、区分业务主流程和分支流程，业务梳理工作是的对象首先要放在核心主流程上。
	b、概括归纳业务分支流程，业务分支流程往往有通用点，可将业务相似的分支流程归为同一类型。
	c、识别业务流程数据信息流，双方数据传输的先后顺序、路径等。
	d、识别业务数据流功能字段，识别字段的含义和重要程度。
```

```python
# 5、业务风险点识别
	a、业务环节存在的风险
	b、支撑系统存在的风险
	c、业务环节之间存在的风险
	d、支撑系统之间存在的风险
	e、业务环节和支撑系统之间存在的风险
```

```python
# 6、开始测试
```

```python
# 7、撰写报告
```



## 二、技术

### 2、登录认证模块

​	2.1、暴力破解

```python
# 测试原理和方法
1、原理：
	针对应用中的用户登录账号和密码进行穷举测试，针对账号和密码进行逐一比较，直到找出正确的账号和密码。
2、场景：
	a、已知账号，加载密码字典针对密码进行穷举测试
	b、未知账号，加载账号字典和密码字典进行穷举测试
	c、未知账号，加载账号密码字典进行穷举测试
```

```python
# 测试流程
1、浏览器代理配置
2、BurpSuite抓包
3、Inturder爆破
```

```python
# 修复方案
1、增加验证码，登录失败一次，验证码更换一次。
2、配置登录失败次数限制，如同一用户尝试登录的情况下，5分钟内连续登录失败6次，禁止半小时内登录系统。
3、特殊情况下，使用邮箱、手机号双验证，实现双因素认证。
```

​	2.2、加密传输

```python
# 原理
	本地加密传输测试是针对客户端与服务端的数据传输，查看数据是否采用安全套接层（Security Socket Layer）加密方式传输。
```

```python
# 测试流程
1、开启Wireshark捕获对应网卡数据。
2、浏览器中访问要测试的HTTPS协议网站，输入用户名和密码尝试登录。
3、Wireshark中找到对应HTTPS测试网站的数据包，分析数据包，查看交互数据是否真正加密。
```

```python
# 修复方案
在架设Web应用的服务器上部署有效的SSL证书服务。
```

​	2.3、Seesion测试

- Session固定测试

```python
# 原理
	Session是应用系统对浏览器客户端身份认证的标识，在用户退出应用系统时，应将客户端Session认证的标识情况。如果应用未能清空客户端的Session标识，在下次登录系统时，系统会重复利用该Session标识进行认证。攻击者可利用该漏洞生成固定Session会话，诱使用户利用攻击者生成的固定会话进行登录，从而导致用户会话认证被窃取。
```

```python
# 测试流程
1、BurpSuite抓包
2、在已登录授权认证的页面进行用户退出
3、查看BurpSuite中本次退出请求的数据，对授权的SessionId进行记录
4、重新登录系统
5、查看BurpSuite中本次退出请求的数据，比对上次登录的授权SessionID
```

```python
# 修复方案
	在客户端登录系统时，首先判断客户端是否提交了浏览器留存的Session标识，若客户端提交此会话至服务器，应及时销毁浏览器留存的Session，并要求客户端浏览器重新生成Session认证标识。
```

- Session注销测试

```python
# 测试原理和方法
	Session是应用系统对浏览器客户端身份认证的标识，在用户退出应用系统时，应将客户端Session认证的标识情况。如果应用未能清空客户端的Session标识，在下次登录系统时，系统会重复利用该Session标识进行认证。攻击者可利用该漏洞生成固定Session会话，诱使用户利用攻击者生成的固定会话进行登录，从而导致用户会话认证被窃取。
```

```
# 测试流程
1、Bursuite抓包
2、用户执行操作
3、将带有用户SessionID的数据包发送到Repeater模块
4、用户退出系统
5、Repeater模块中相应授权数据包点击"GO"，再次发送授权访问请求，查看系统是否对退出后的用户授权Session解除授权
```

```python
# 修复方案
	在用户注销或退出系统时，服务器应即使销毁Session认证信息并清空客户端浏览器的Session标识。
```

- Session超时时间测试

```python
# 原理
	在用户成功登录系统获得Session认证会话后，该Session应具有生命周期，即用户在成功登录系统后，如果在指定时间内（如10分钟）该用户与服务器无任何交互操作，应销毁该用户Session认证会话信息，要求用户重新登录系统认证。
```

```python
# 测试流程
1、Bursuite抓包
2、用户执行操作
3、将带有用户SessionID的数据包发送到Repeater模块
4、在无交互的30分钟后重放该数据包，查看系统返回结果是否存在授权后可查阅的特殊信息
```

```python
# 修复方案
	对每个生成的Session认证会话配置生命周期（常规业务系统建议30分钟内），从而有效降低因用户会话认证时间过程而导致的信息泄露风险。
```

​	2.4、Cookie冒充

```python
# 原理
	服务器为鉴别客户端浏览器会话及身份信息，会将用户身份信息存储在Cookie中，并发送至客户端存储。攻击者通过尝试修改Cookie中的身份标识，从而达到仿冒其他用户身份的目的，并拥有该用户的所有权限。
```

```python
# 测试流程
1、BurpSuite抓包
2、使用1234账号登录系统并刷新浏览器页面
3、将BurpSuite截取的数据包中Cookie中uid改为5678再提交
4、查看提交后的返回信息，账号身份授权被修改
```

```python
# 修复方案
	对于客户端用户的敏感数据，使用Session会话认证方式，避免被他人仿冒身份。
```

​	2.5、密文对比

```python
# 原理
	系统登录时密码加密流程一般是先将用户的用户名和密码发送到服务器，服务器将用户提交的密码经过Hash算法加密后和数据库中的加密值对比，如果加密值相同，则判定用户密码正确。
	部分网站系统的流程是在前端对密码进行Hash加密，导致泄露密码加密方式，造成安全隐患。
```

```python
# 测试流程
1、BurpSuite抓包
2、输入用户名密码
3、查看数据包中的加密类型为MD5
4、在Intruder模块Payloads选项卡中Payload Processing单击"Add"按钮，选择"Hash"和"MD5"进行爆破
```

```python
# 修复方案
	将密码加密过程及密文比对过程放在服务器后台执行。发送用户名和密码到服务器后台，后台对用户提交的密码经过MD5算法加密后和数据库中存储的MD5密码值进行比对，加密值相同，则允许用户登录。
```

​	2.6、登录失败信息

```python
# 原理
	用户登录系统失败时，系统会在页面显示用户登录的失败信息。如提交账号在系统中不存在，系统提示"用户名不存在"；若账号在系统中存在，则提示"密码错误"。攻击则会可根据此类登录失败提示信息来判断当前登录账号是否在系统中存在，从而进行针对性的密码暴力破解。
```

```python
# 测试流程
1、登录系统页面输入不存在的账号信息提交，系统返回"用户名不存在"。
2、输入存在的账号信息提交，系统返回"密码错误"。
```

```python
# 修复方案
	系统登录失败时，采用统一的模糊描述（如登录账号或密码错误），从而提高攻击者对登陆系统用户名及密码的猜测难度。
```



### 3、业务办理模块

​	3.1、订单ID篡改

```python
# 原理
	在电子交易业务的网站中，用户登录后可以下单购买相应产品，购买成功，用户可以查看订单的详情。当开发人员没有考虑登录后用户之间权限隔离的问题时，就会导致平行权限绕过漏洞。攻击者只需注册一个普通账号，就可以通过篡改、遍历订单id，获得其他用户订单详情，其中可能会包括用户的姓名、身份证、地址、电话号码等敏感信息。黑色产业链中的攻击者也常用此漏洞获取隐私信息。
```

```python
# 测试流程
1、登录1234账号，查看本人订单
2、抓包修改订单号，可越权查看他人订单内容（以及数据包中被隐藏的全部身份证号等）
```

```python
# 修复方案
	后台查看订单要通过Session机制判断用户身份，做好平行权限控制，通过校验订单信息和登录者的身份是否一致，不一致则拒绝请求。
```

​	3.2、手机号篡改

```python
# 原理
	手机号通常可以代表一个用户身份，当请求中发现有手机号参数时，可以尝试修改它，测试是否存在越权漏洞。
```

```python
# 测试流程
1、以尾号1234手机登录，选择挂失业务
2、抓包修改为尾号6789手机号
3、修改成功，成功挂失尾号为6789的手机号
```

```python
# 修复方案
	用户请求要通过Session机制判断身份，如果需要客户端传输手机号码，则服务端需要校验手机号是否和登陆这的Session身份一致，如发现不一致则拒绝请求。
```

​	3.3、用户ID篡改

```python
# 原理
	开发者在设计用户登录查看个人信息时，需要通过SessionID判定用户身份，然后显示用户相应的个人信息。但有时我们会发现在GET或POST请求中有uid这类参数传输，并且后台通过此参数显示对应用户的隐私信息，这就导致攻击者可以通过篡改用户ID越权访问其他用户隐私信息。
```

```python
# 测试流程
1、登录用户，修改收货地址并抓包
2、发现uid参数1234，并将1234改为1233
3、提交后返回uid为1233用户的收货地址信息
```

```python
# 修复方案
	用户请求要通过Session机制判断身份，如果需要客户端传输uid，则服务端需要校验uid是否和登录者的Session身份一致，如发现不一致则拒绝请求。
```

​	3.4、邮箱和用户篡改

```python
# 原理
	在发送邮件或站内消息时，篡改发件人参数，导致攻击者可以伪造发信人进行钓鱼攻击等操作，这也是水平越权的一种。
```

```python
# 测试流程
1、编写邮件，点击发送
2、BurpSuite截取并修改数据包中发件人参数值，提交发送
3、收件时，发现收件人被篡改成功
```

```python
# 修复方案
	用户请求要通过Session机制判断身份，如果需要客户端传输邮箱、发件人，则服务端需要校验邮箱、发件人是否和登录者的Session身份一致，如发现不一致则拒绝请求。
```

​	3.5、商品编号篡改

```python
# 原理
	交易支付类型的业务中，最常见的业务漏洞就是修改商品金额，除了直接篡改商品金额，还可以篡改商品编号，同样会造成实际金额与商品不对应，却又成功交易的情况。攻击者可以利用此业务漏洞低价购买高价物品。
```

```python
# 测试流程
1、登录积分商城
2、记录30积分的商品编号1234
3、选择商城中编号为5678，积分最低的礼物（5积分）兑换
4、替换数据包中的商品编号为1234
5、订单页面显示用5积分换购了30积分的礼物
```

```python
# 修复方案
	商品金额不要在客户端传入，防止被篡改。如果确实需要在客户端传输金额，则服务端在收到请求后必须检查商品价格和交易金额是否已知，若不一致则阻止该交易。
```

​	3.6、条件竞争

```python
# 原理
	当两个或多个进程试图同时在同一时刻访问共享内存、或读写某些共享数据时，最后的竞争结果却决于线程运行的顺序，成为条件竞争。攻击者通过利用多线程并发请求，在数据库中的余额字段更新之前，多次兑换积分或购买商品，从而获得利益。
```

```python
# 测试流程
1、点击退款
2、BurpSuite抓取数据包，多线程重放此数据包
3、交易成功，生成两单退款申请，同时金额变成负数，未经过财务审核，直接到账2笔退款
```

```python
# 修复方案
	在处理订单、支付等关键业务时，使用悲观或乐观锁保证事务ACID特性（原子性、一致性、隔离性、持久性），并避免脏读（一个事务读取了另一个事务未提交的数据）
```



### 4、业务授权访问

​	4.1、未授权访问测试

```python
# 原理
	未授权访问是指用户在没有通过认证授权的情况下能够直接访问需要通过认证才能访问到的页面或文本信息。可以尝试在登录某网站后台之后，将相关的页面链接复制到其他浏览器或其他电脑上进行访问，观察是否能访问成功
```

```python
# 测试流程
1、在IE浏览器中某网站进行缴费
2、复制缴费成功的URL，在火狐浏览器中访问，成功访问
```

```python
# 修复方案
	对未授权访问页面做Session认证，并对用户访问的每一个URL做身份鉴别，正确校验用户ID和Token
```

​	4.2、越权测试

```python
# 原理
	越权分为水平越权和垂直越权。水平越权指相同权限的不同用户可以互相访问；垂直越权指使用权限低的用户可以访问权限较高的用户。
```

```python
# 测试流程

# 水平越权
1、创建任务并抓包
2、查看数据包中类似ID的参数
3、Burpsuite爆破该ID值，响应状态码为200，且相应长度不同
4、查看数据包中回显页面，成功越权
# 垂直越权
1、登录1234用户
2、得知账号管理员账号为admin
3、修改密码为11223344并抓包
4、将数据包中uid为123的值修改为admin并提交
5、页面提示密码修改成功
```

```python
# 修复方案
	服务端需校验身份唯一性，自己的身份只能查看、修改、删除、添加自己的信息
```



### 5、输入输出模块

​	5.1、SQL注入测试

```python
# 原理
	SQL注入就是通过把SQL命令插入Web表单提交或输入域名页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令的目的
```

```python
# 测试流程

# 数字型
1、正常访问，查看页面，在参数后添加单引号，页面报错
2、删除单引号，添加and 1=1，页面正常
3、删除and 1=1，添加and 1=2，页面报错
# 字符型
1、正常访问，抓包并查看页面
2、添加'or'1'='1，页面正常
```

```python
# 修复方案
	过滤SQL语句关键字：and、or、select、declare、update、xp_cmdshell
	过滤SQL语句特殊符号：' " ; -- #等
```

​	5.2、XSS测试

```python
# 原理
	跨站脚本漏洞时web应用在将数据输出到网页的时候存在问题，导致恶意攻击者可以往Web页面中插入恶意Javascript、HTML代码，并将构造的恶意数据显示在页面的漏洞中。
```

```python
# 测试流程

# 反射型
1、抓包并在工单编号处添加XSS Payload
2、成功弹出对话框
# 存储型
1、在新建、编辑、删除的模块添加XSS Payload
2、成功弹出对话框，并将数据存储在了数据库
```

```python
# 修复方案
1、过滤特殊符号：< " ' %等
2、过滤关键字：Javascript、script等
```

​	5.3、命令执行测试

```python
# 原理
	在应用需要调用一些外部程序去处理内容的情况下，会用到一些执行系统命令的函数。如PHP中的system、exec、shell_exec等，当用户可以控制命令执行函数中的参数时，将可注入恶意系统命令到正常命令中，造成命令执行攻击。
```

```python
# 测试流程
1、ping自己的主机并抓包
2、数据包中IP参数接受一个参数并执行Ping命令，如果接收的餐宿没有过滤就可以用"& | || ;"构造语句，进行命令执行楼哦的功能测试，成功执行系统命令。
```

```python
# 修复方案
	尽量少用执行命令的函数或者直接禁用。
```



### 6、回退模块

​	6.1、回退测试

```python
# 原理
	大部分Web业务在密码修改成功后或订单付款成功后等业务模块，在返回上一步重新修改密码或者重新付款时存在重新设置密码或付款的功能，如果能返回上一步重复操作，而且还能更改或重置结果，则存在业务回退漏洞。
```

```python
# 测试流程
1、正常更改密码
2、尝试是否可以进行回退，是否可以修改密码
```

```python
# 修复方案
	对于业务流程有多步的情况，如修改密码或重置密码等业务，首先判断该步骤的请求是否时上一步骤的业务所发起的，如果不是则返回错误提示或页面失效。
```



### 7、验证码机制

​	7.1、验证码爆破测试

```python
# 原理
	验证码机制主要被用于防止暴力破解、防止DDOS攻击、识别用户身份等。以短信验证码为例，短信验证码大部分情况由4-6位数字组成，如果没有对验证码的失效时间和尝试失败次数做限制，攻击者就可以通过尝试这个区间内的所有数字进行暴力破解。
```

```python
# 测试流程
1、填写任意号码进行注册，点击获取验证码
2、抓包并点击登录
3、对code参数进行暴力破解
4、通过返回值的长度判断正确验证码
```

```python
# 修复方案
1、设置验证码失效时间，建议为180秒
2、限制固定时间内验证码的失败次数，如5分钟内连续失败5次即锁定该账号15分钟
```

​	7.2、验证码复用测试

```python
# 原理
	在网站的登录或评论等页面，如果验证码认证成功后没有将session及时清空，将会导致验证码首次认证成功之后可重复利用。
```

```python
# 测试流程
1、在客户投诉建议处、输入要投诉的内容，并输入验证码
2、抓取数据包并修改投诉内容参数complaintsContent的值
3、经过暴力重复提交后，客户端显示提交成功
4、返回页面查看历史投诉建议，可看到成功提交了多次投诉
```

```python
# 修复方案
	验证码在一次认证成功后，服务端清空认证成功的session，可以有效防止验证码复用。
```

​	7.3、验证码客户端回显测试

```python
# 原理
	验证在客户端生成而非服务端生成，当客户需要和服务器进行交互发送验证码时，可借助浏览器的工具查看客户端进行交互的详细信息
```

```python
# 测试流程
1、在找回密码页面任意手机号和开户证件号
2、点击下一步，即可向手机发送短信验证码，按F12可看到短信验证码在本地生成
3、输入验证码，重置密码成功
```

```python
# 修复方案
1、禁用验证码在本地客户端生成，采用服务端验证码生成机制
2、设置验证码的时效性，如180秒过期
3、验证码随机生成，用一次即失效
```

​	7.4、验证码绕过测试

```python
# 原理
	通过修改前端提交服务器返回的数据，可实现绕过验证码，执行请求。
```

```python
# 测试流程
1、用户注册页面输入用户名和密码，点击获取验证码
2、输入任意错误验证码
3、Burp截取数据包，右击选择Do intercept-Response to this request
4、点击Forword后，Burp工具显示的就是网站返回的数据包，因为验证码错误，返回的res_code为1
5、修改res_code为0，绕过验证码
6、再次点击Forword后，成功注册
```

```python
# 修复方案
	在服务端增加验证码认证机制，对客户端提交的验证码进行二次校验
```

​	7.5、验证码自

### 8、业务数据安全

​	8.1、商品支付金额篡改测试

```python
# 原理
	通过抓包修改业务流程中的交易金额等字段，例如在支付页面抓取请求中商品的金额字段，修改成任意数额的金额并提交，查看能否以修改后的金额数据完成业务流程。
```

```python
# 测试流程
1、购卡选择面值后进入支付平台页面
2、抓包并修改支付请求中的明文金额字段
3、跳转支付平台，完成修改后订单金额支付流程
4、支付完成后自动返回商城，显示订单成功生成并完成支付
```

```python
# 修复方案
	商品信息，如金额、折扣等原始数据的校验应来自于服务端，不应接受客户端传递的值
```

​	8.2、商品数量篡改测试

```python
# 原理
	商品数量篡改时通过在业务流程中抓包修改商品数量等字段，如修改为负数后提交
```

```python
# 测试流程
1、将商品加入购物车
2、在购物车中进行兑换
3、抓包将商品数量参数修改为负数后保存并发送
4、添加兑换人的配送信息，确认订单信息，完成积分兑换业务流程
5、查看兑换结果
```

```python
# 修复方案
	服务端应考虑交易风险控制，对产生异常情况的交易行为（如订单中商品数量为0或负数）应当直接予以限制、阻断。
```

​	8.3、前端JS限制绕过测试

```python
# 原理
	很多商家在限制购买数量时，仅在前端JS进行限制，未在服务端进行校验用户提交的数量。通过修改JS端商品数量最大限制的值，查看能否以非正常业务交易数据完成业务流程
```

```python
# 测试流程
1、将限制购买数量的商品加入到购物车
2、发现客户端在前端浏览器做了购买限制
3、点击提交，通过抓包修改数值为100，放包
```

```python
# 修复方案
	对于跨平台支付业务，设计平台之间接口调用，要做好对重要数据，如金额、商品数量的完整性、合法性进行校验，确保业务重要数据在平台传输的一致。
```

​	8.4、请求重放测试

```python
# 原理
	请求重放是电商平台业务逻辑漏洞中一种常见的由设计缺陷所引发的漏洞。当用户首次购买成功后，参照订单商品的正常流程请求，进行完全模拟正常订购业务流程的重放操作，可以实现"一次付款多次收获"的效果。
```

```python
# 测试流程
1、在生成订单流程时抓取订购请求
2、观察每次订购相同商品的请求是否存在不同的随机Token、可变参数等
3、尝试重放之前已经完成流程的订购请求，若订购再次生效，则表明存在请求重放漏洞
```

```python
# 修复方案
	对于订单生成的关键环节，对订单Token对应的订购信息内容、用户身份、用户可用积分等进行强校验
```

​	8.5、业务上限测试

```python
# 原理
	通常情况，在业务流程中通过向服务端提交高于或低于预期的数据以校验服务端是否对所提交的数据做强校验，若查询到超出预期的信息、订购或兑换超出预期范围的商品，则表示存在漏洞。
```

```python
# 测试流程
1、在业务查询-受理记录查询中，应用程序只允许登录用户查询6个月以内的记录
2、将数据包中的month参数修改为12并提交
```

```python
# 修复方案
	对于订单生成的关键环节，对订单Token对应的订购信息内容、用户身份、用户可用积分等进行强校验。
```



### 9、业务流程乱序

​	9.1、业务流程绕过测试

```python
# 原理
	该测试主要针对业务流程的处理流程是否正常，确保攻击者无法通过技术手段绕过。例如业务流程分为3步，第一步，注册并发送验证码；第二步，输入验证码；第三步注册成功。在第三步进行抓包分析，将邮箱或手机号替换为其他人的，如果注册成功，就跳过的第一步和第二步，绕过正常的业务流程。
```

```python
# 测试流程
1、登录用户1
2、对账号充值并抓包，金额为100
3、截取支付订单数据包，放弃支付，获取生成的订单号
4、利用获取的订单号构造链接，直接访问这个链接即可成功充值
```

```python
# 修复方案
	对于敏感信息如身份ID、账号密码、订单号、金额等进行加密处理，并在服务端进行二次对比。
```



### 10、业务接口调用

​	10.1、接口调用重放测试

```python
# 原理
	在短信、邮件调用业务或生成业务数据环节中，如短信验证码、邮件验证码、订单生成、评论提交等，对业务环节进行调用（重放）测试，如果能够生成有效的业务或数据结果，则存在接口调用问题。
```

```python
# 测试流程
1、在购买机票"提交订单"环节抓取数据包
2、通过BurpSuite进行重放测试
3、查看返回结果，重复生成
```

```python
# 修复方案
1、对生成订单环节采用验证码机制，防止生成数据业务被恶意利用
2、每一个订单使用唯一的Token，订单提交一次后，Token失效
```

​	10.2、接口调用遍历测试

```python
# 原理
	Web接口一般将常见的一些功能需求进行封装，通过传入不同的参数获取数据或执行相应的功能，最常见的就是通过接口传入ID参数，返回对应ID的信息。攻击者通过BurpSuite作为代理，记录所有请求和相应信息，通过Burpsuite以登录后的状态对整个网站进行爬取，再使用过滤功能找到传入id参数的HTTP请求，通过Intruder对id参数进行遍历，查看是否返回不同的响应信息。
```

```python
# 测试流程
1、使用BurpSuite爬虫功能，从根目录开始爬取，在HTTP history选项中选择要开始爬取的项，右击选择"Spider from here"，爬取登录后的网站链接。
2、查看Target-Site map，使用BP的过滤功能筛选出带有uid参数的链接
3、选择自己想要的链接，发送到Intruder，设置后四位数字为变量进行爆破
4、找到规律，筛选成功的数据包
```

```python
# 修复方案
	在Session中存储当前用户的凭证或id，只有传入凭证或id参数与Session一致才返回数据内容
```

​	10.3、接口调用参数篡改测试

```python
# 原理
	在短信、邮件调用业务环节中，修改请求中手机号或邮箱地址提交，如果收到小心，则表示接口数据调用参数可篡改
```

```python
# 测试流程
1、在短信验证码页面单机"重新发送"并抓包
2、将数据包的手机号修改为其他手机号
3、收到相应短信验证码
```

```python
# 修复方案
1、会话Session中存储重要的凭证，在忘记密码、重新发送验证码等业务中，从Session获取凭证而不是从客户请求的参数中获取。
2、从客户端获取手机号、邮箱等账号信息，要与Session中的凭证进行对比，一致才允许进行业务操作
```

​	10.4、接口未授权访问

```python
# 原理
	敏感功能接口没有身份校验，攻击者无需登录或验证即可调用接口进行操作。
```

```python
# 测试流程
1、登录后使用BP的爬虫功能，从根目录开始爬取，在HTTP history中选择要爬取的项，右击选择"Spider from here"。爬取结果在Target-site map中显示
2、使用BP的MIME type过滤功能，筛选出接口相关的HTTP请求，重点关注json、script、xml、text MIME type等
3、对接口相关请求进行查看，查看是否存在敏感信息
4、将完整的URL复制到其他浏览器，查看是否返回敏感信息
```

```python
# 修复方案
1、采用Token校验的方式，在url中添加一个Token参数，只有Token验证通过才返回数据，且Token在使用一次后失效
2、在接口被调用时，如果用户未登录，则返回自定义的错误信息
```

​	10.5、Callback自定义测试

```python
# 原理
	浏览器存在同源策略，即域名、协议、端口相同，使用Ajax异步传输数据时，非同源域名之间会存在限制。JSONP原理是利用了HTML里script标签，远程调用JSON文件实现数据传输。JSONP技术一般使用Callback（回调函数）参数来声明回调时所使用的函数名，由于没有使用白名单限制，导致用户可以自定义Callback内容，触发XSS漏洞。
```

```python
# 测试流程
1、登录后使用BP的爬虫功能，从根目录开始爬取，在HTTP history中选择要爬取的项，右击选择"Spider from here"。爬取结果在Target-site map中显示
2、使用BP的MIME type过滤功能，筛选出接口相关的HTTP请求，找到URL带有callback参数的链接
3、查看URL对应的HTTP Response中Content-Type类型是否为text/html。如果是，我们输入的HTML标签才会被浏览器解析
4、将请求发送到Repeater，测试h1标签是否正常解析
5、将callback参数更换为带有恶意行为的HTML标签
```

```python
# 修复方案
1、严格定义HTTP响应中的Content-Type为json数据格式
2、建立callback白名单
3、对callback参数HTML实体编码过滤 < > 等字符
```

​	10.6、WebService测试

```python
# 原理
	WebService是一个应用程序向外界暴露处一个能够通过Web进行调用的API。这个API接收用户输入的参数，然后返回相关的数据内容。如果一个WebService对用户输入不过滤，则可能导致SQL注入漏洞。
```

```python
# 测试流程
无
```

```python
# 修复方案
1、为WebService添加身份认证，认证成功才允许访问和调用
2、WebService中接收输入参数的函数，在后端应该对输入参数进行过滤才入库查询
3、对于敏感功能的函数，添加密码认证，认证后才允许调用敏感功能函数
```